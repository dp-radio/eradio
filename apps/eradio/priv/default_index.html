<html>
  <body>
    <button class="play-button">
      <span>Play</span>
    </button>
    <button class="veto-button">
      <span>Veto</span>
    </button>
    <audio class="player" preload="none">
      <source class="player-source" src="data:" type="audio/mpeg"></source>
    </audio>
    <br/>
    <div class="player-status">Not Playing</div>
    <div class="metadata"></div>
    <span class="listener-count"></span>,
    <span class="veto-count"></span>
    <script>
      const playButton = document.querySelector('.play-button');
      const vetoButton = document.querySelector('.veto-button');
      const player = document.querySelector('.player');
      const playerSource = document.querySelector('.player-source');
      const playerStatusDiv = document.querySelector('.player-status');
      const metadataDiv = document.querySelector('.metadata');
      const listenerCountSpan = document.querySelector('.listener-count');
      const vetoCountSpan = document.querySelector('.veto-count');
      const listenerId = Math.floor(Math.random() * 4294967296);

      const loadingTexts = ["Loading.", "Loading..", "Loading..."];
      function getLoadingText() {
          return loadingTexts[Math.floor(Math.random() * loadingTexts.length)];
      }

      let lastPlayerLoad = 0;
      function tryLoadPlayer() {
          let now = Date.now();
          let duration = Math.abs(now - lastPlayerLoad);
          if (duration > 2000) {
              console.log("reloading player");
              playerStatusDiv.textContent = getLoadingText();
              playerSource.src = "/stream.mp3?listener_id="+listenerId+"&time="+now;
              player.load();
              player.play();
              player.currentTime = 10;
              lastPlayerLoad = Date.now();
          } else {
              console.log("inhibiting player reload after only "+duration+"ms");
          }
      }

      function getPlayerLag() {
          let playerLag = null;
          if (player.buffered.length != 0) {
              let bufferedLag = (player.buffered.end(player.buffered.length - 1) - player.currentTime);
              playerLag = Math.max(playerLag || 0, bufferedLag);
          }
          if (player.seekable.length != 0) {
              let seekableEnd = player.seekable.end(player.seekable.length - 1);
              if (isFinite(seekableEnd)) {
                  let seekableLag = (seekableEnd - player.currentTime);
                  playerLag = Math.max(playerLag || 0, seekableLag);
              }
          }
          return playerLag;
      }

      function updatePlayerLag() {
          let playerLag = getPlayerLag();
          if (playerLag != null) {
              if (playerLag > 3) {
                  let playerLagText = playerLag.toLocaleString([], {maximumFractionDigits: 2});
                  playerStatusDiv.textContent = "Playing ("+playerLagText+" seconds behind)";
              } else {
                  playerStatusDiv.textContent = "Playing";
              }
          } else  {
              playerStatusDiv.textContent = getLoadingText();
          }
      }

      function getMetadata() {
          return new Promise(function (resolve, reject) {
              let xhr = new XMLHttpRequest();
              xhr.open("get", "/v1/metadata", true);
              xhr.responseType = "json";
              xhr.onload = function() {
                  if (this.status >= 200 && this.status < 300) {
                      resolve(xhr.response);
                  } else {
                      reject({ status: this.status, statusText: xhr.statusText });
                  }
              };
              xhr.onerror = function() {
                  reject({ status: this.status, statusText: xhr.statusText });
              };
              xhr.send();
              
          });
      }

      async function updateMetadata() {
          let metadata = null;
          try {
              metadata = await getMetadata();
          } catch(error) {
              console.log("error fetching metadata: "+error);
          }
          while (metadataDiv.firstChild) {
              metadataDiv.removeChild(metadataDiv.firstChild);
          }
          if (metadata != null) {
              if (metadata.current_track != null) {
                  let metadataLink = document.createElement("a");
                  metadataLink.href = metadata.current_track.uri;
                  metadataLink.target = "_blank";
                  metadataLink.textContent = metadata.current_track.name;
                  metadataDiv.appendChild(metadataLink);
              } else {
                  let metadataSpan = document.createElement("span");
                  metadataSpan.textContent = "No Song Playing";
                  metadataDiv.appendChild(metadataSpan);
              }

              listenerCountSpan.textContent = metadata.listener_count + " listeners";
              vetoCountSpan.textContent = metadata.veto_count + " vetoes";
          }
          setTimeout(updateMetadata, 1000);
      }

      function veto() {
          let xhr = new XMLHttpRequest();
          xhr.open("put", "/v1/veto?listener_id="+listenerId, true);
          xhr.send();
      }

      playButton.onclick = () => {
          tryLoadPlayer();
      };

      vetoButton.onclick = () => {
          veto();
      };

      player.onstalled = (event) => {
          console.log("playback stalled...");
          tryLoadPlayer();
      };

      player.onsuspend = (event) => {
          console.log("playback suspended...");
      };

      player.ontimeupdate = (event) => {
          updatePlayerLag();
      };

      updateMetadata();
    </script>
  </body>
</html>
